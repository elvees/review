==========
Ядро Linux
==========

Данные правила дополняют, расширяют и заменяют правила разработки ядра Linux 4.20 и ПО,
описанные в документах:

* `Documentation/process`_;
* правилах по разработке программного обеспечения;
* правилах оформления сообщений к коммитам.

.. _Documentation/process: https://www.kernel.org/doc/html/v4.20/process/

Оформление коммитов
===================

Изменения для поддержки процессора и поддержки платы должны отправляться отдельными коммитами.
Префикс заголовка сообщения к коммиту должен соответствовать префиксам использовавшимся для
данного драйвера/подсистемы/процессора/платы ранее.

Набор правил, проверяемых скриптом ``scripts/checkpatch.pl`` (входит в состав исходных кодов ядра
Linux), ослаблен. Пример проверки последнего коммита:

.. code:: shell

   git format-patch --no-stat -1 HEAD

   scripts/checkpatch.pl \
     --ignore=GERRIT_CHANGE_ID,UNDOCUMENTED_DT_STRING,FILE_PATH_CHANGES,BLOCK_COMMENT_STYLE \
     --min-conf-desc-length=1 \
     --no-tree \
     *.patch

Подробнее про использование checkpatch.pl — см. `Submitting patches`_.

.. _Submitting patches: https://www.kernel.org/doc/html/v4.20/process/submitting-patches.html#style-check-your-changes

Именование
==========

Публичные и внутренние функции, типы, глобальные переменные и макроподстановки должны иметь
префикс в виде имени драйвера.

Примеры:

.. code:: c

   // Тип и макроподстановки
   enum vinc_ycbcr_encoding {
       VINC_YCBCR_ENC_601    = 0,
       VINC_YCBCR_ENC_709    = 1,
       VINC_YCBCR_ENC_BT2020 = 2,
       VINC_YCBCR_ENC_SYCC   = 3
   };

   // Тип
   struct vinc_cam {
       unsigned int width;
       unsigned int height;
       u32 code;
   };

   // Глобальная переменная
   static struct soc_mbus_pixelfmt vinc_formats[] = {
       ...
   };

   // Функция
   static void vinc_start_capture(struct vinc_dev *priv,
                                  struct soc_camera_device *icd)
   {
       ...
   }

Если определять типы без префиксов, то возможна ситуация, когда при изменении конфигурации ядра,
начинает объявляться новый общий тип, который имеет то же имя, что и тип внутри драйвера. Это
приводит, во-первых, к предупреждению. Во-вторых, в GDB нельзя специфицировать структурные типы
специфичные для единиц трансляции (файлов). typedef можно, struct нельзя. При остановке внутри
функции GDB корректно находит локальные типы, но извне явно указать тип нельзя (недоработка GDB).
Аналогично, с макросами возникают предупреждения.

Могут не иметь префиксов:

* Глобальные переменные параметров модуля.
* Статические функции, которые не используются в качестве функций обратного вызова (callback).
